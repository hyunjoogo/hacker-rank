


/*
Quicksort는 보통 실행 시간이 A인데, 더 빨리 정렬할 수 있는 알고리즘이 있을까요?
일반적으로, 이것은 가능하지 않습니다.
대부분의 정렬 알고리즘은 비교 정렬입니다.
즉, 요소를 서로 비교하는 것만으로 목록을 정렬합니다.
비교 정렬 알고리즘은 A(최악의 경우) 실행 시간을 초과할 수 없습니다.
A는 각 요소를 배치하는 데 필요한 최소 비교 수를 나타내기 때문입니다.
자세한 내용은 다음 참고 사항(PDF)을 참조하십시오.


* 또 다른 정렬 방법인 계수 정렬은 비교할 필요가 없습니다.
* 대신 정렬할 배열의 전체 값 범위를 포함하는 인덱스 범위를 가진 정수 배열을 만듭니다.
* 원래 배열에서 값이 발생할 때마다 해당 인덱스에서 카운터가 증가합니다.
* 마지막으로 카운트 배열을 실행하여 0이 아닌 각 값 인덱스의 값을 해당 횟수만큼 인쇄합니다.
*
* arr = [1,1,3,2,1];
* 모든 값이 [0...3] 범위에 있으므로 0, result = [0,0,0,0]의 배열을 만듭니다. 각 반복의 결과는 다음과 같습니다.
*
* 빈도 Array는 [0,3,1,1]. 이러한 값은 정렬된 배여을 생성하는데도 사용할 수 있다.
* */
// arr의 값들의 범위가 0~3이므로 result의 랭스를 4로 하고 모든 값을 0으로 할당
// int[100]: a frequency array


const arr = [1,1,3,2,1];

// 왜 result의 length는 arr보다 하나 작을까?

const result = new Array(100).fill(0);
arr.forEach(number => result[number]++);

console.log(result);
// return result;
